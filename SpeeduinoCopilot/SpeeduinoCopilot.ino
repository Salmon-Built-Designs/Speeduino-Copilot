//////////////////////////////////////
// Speeduino Copilot
// Mike Scott
// December 2020
// intended as a separate data logging device to allow MGVLG format files
// to be generated by teensy 3.5 SerialSpeeduino connected to the Secondary Serial of 
// a Speeduino. 
// This might be useful to have the SD card remote from the main ECU (for example
// in a motorcylce where the ECU is tucked behind difficult-to-access fairing panels)
// The teensy can be on a separate board, connected over serial and placed in a more
// accessible area.

#include <TinyGPS.h>
#include "mgvlg.h"
#include "speeduino.h"

#define PACKETLENGTH 256
//#define DEBUG
IntervalTimer Timer1Hz;
IntervalTimer Timer10Hz;

TinyGPS gps;
#define SerialGPS Serial2
#define SerialSpeeduino Serial1

void errorHalt(const char* msg) {
  Serial.print("Error: ");
  Serial.println(msg);
  while (true) {}
}

void setup()
{
  Serial.begin(115200);
  SerialSpeeduino.begin(115200);
  SerialGPS.begin(9600);
  Serial.println("Initialising");
  delay(2000);

  // Initialise the SD and write MGVLG headers ready for data
  mgvlgInit();

#ifdef GPS
  // check and set date/time from GPS - this might necessitate an additional startup delay
#endif //GPS
  // Inexpensive GPS modules update at 1Hz so let's only check it once a second. 
  Timer1Hz.begin(ISR_1Hz,1000000); 
  Timer10Hz.begin(ISR_10Hz,100000); 
  pinMode(2, INPUT);
  attachInterrupt(digitalPinToInterrupt(2),ISR_HW, FALLING);
}

boolean RTC_is_set=false;
double lat=0;
double lng=0;

////////////////////////////////
// 1Hz ISR routine
volatile boolean FLAG_1Hz=false;
void ISR_1Hz() {
  // Let's just set a flag that the main loop will pick up
  FLAG_1Hz=true;
}
volatile boolean FLAG_10Hz=false;
void ISR_10Hz() {
  // Let's just set a flag that the main loop will pick up
  FLAG_10Hz=true;
}
volatile boolean FLAG_HW=false;
void ISR_HW() {
  // Let's just set a flag that the main loop will pick up
  FLAG_HW=true;
}


////////////////////////////////
// Main loop

void loop() {
  // structure for data recieved from Speeduino
  byte dataReceived[PACKETLENGTH];

  if (FLAG_10Hz) {
    FLAG_10Hz=false;
    // Wait for serial to be available
    while(SerialSpeeduino.availableForWrite()==0) {}
    SerialSpeeduino.write("n");
    while (SerialSpeeduino.available()<3) {}
    byte n=SerialSpeeduino.read();
    byte type=SerialSpeeduino.read();
    byte bytesIncoming=SerialSpeeduino.read();
  
    int bytesRead=SerialSpeeduino.readBytes((byte*)dataReceived,(int)bytesIncoming);

    if (bytesRead<bytesIncoming) {
      Serial.println("WARNING: Short read");
    }

    type+=0;
    n+=0;
#ifdef DEBUG
    Serial.print("n:");
    Serial.print((int)n);
    Serial.print(" type:");
    Serial.print((int)type);
    Serial.print(" bytesIncoming:");
    Serial.println((int)bytesIncoming);

#endif //DEBUG
    // write a data record to the logfile
    writeRecord((byte*)dataReceived,lat,lng);

    while (SerialGPS.available()) {
      gps.encode(SerialGPS.read()); // Send it to the encode function
    }
  }
   
  if (FLAG_1Hz) {
    FLAG_1Hz=false;
    Serial.println("1Hz Routine");
#ifdef GPS
    Serial.println("Get and update GPS coordinates, if we have position lock";
    // check and set date/time from GPS
    while (SerialGPS.available()) {
      gps.encode.(SerialGPS.read()); // Send it to the encode function
    }
    if (gps.isValid() && gps.age()<1500) {
      // GPS data is valid, and is less than 1500ms old
      double lat,lng;
      lat=gps.location.lat();
      lng=gps.location.lng();

      if (RTC_is_set==false) {
        int y,m,d,H,M,S;
        y=gps.date.year();
        m=gps.date.month();
        d=gps.date.date();
        H=gps.time.hour();
        M=gps.time.minute();
        S=gps.time.second();
        setTime(H,M,S,d,m,y);
        RTC_is_set=true;
      } else {
        lat=0;
        lng=0;
      }
    }
#endif
  }

  if (FLAG_HW) {
      FLAG_HW=false;
      Serial.println("Drop marker");
      writeMarker(lat,lng);
  }
}
